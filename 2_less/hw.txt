Контрольные вопросы

1 - применение std::pair  и std::tuple

    Класс pair интерпретирует два значения как одно целое. 
    Pair используют контейнерные классы map, multimap, unordered_map и 
    unordered_multimap для управления своими элементами, представляющими собой пары «ключ/значение». 
    Другой пример – функции, возвращающие два значения( minmax). 
    Также можно обрабатывать значения, являющихся элементами класса pair.
     
    Tuple используют для выяснения количества элементов, для распознавания типа
    конкретного элемента, для доступа к элементам. 
      
    Шаблонная функция make_pair позволяет создавать пары значений, не указывая типы 
    элементов явно. Шаблонная функция make_tuple позволяет создать 
    кортеж значений без явного указания их типов.

2 - использование std::array

    Объект класса array управляет своими элементами, хранящимися в 
    массиве фиксированного размера. Таким образом можно менять толькоъ
    значения элементов, но не их количество. Массивы обеспечивают прямой
    доступ и явлются разновидностью упорядоченной коллекции. 
    Наилучшая производительность для последовательности, состоящей 
    из фиксированного количества элементов.

3 - использование std::vector

    Вектор управляет элементами, хранящимися в динамическом массиве. 
    Он обеспечивает произвольный доступ к элементам, очень быстро вставка
    и удаление в конце. Вектор также обеспечивает прямой доступ. 

4 - использование std::deque

    Дек – динамический массив, может расти в обоих направлениях. 
    Таким образом, вставка элемента в конец и в начало выполняется быстро.
    Размер дека может уменьшаться, так как блоки памяти можно 
    освобождать. Дек можно использовать, если мы не собираемся ссылаться
    на элементы контейнера.

5 - использование std::list

    Двусвязный список элементов. Не поддерживает произвольный доступ к 
    элементам. Однако переход к следующему или предыдущему элементу 
    выполняется за константное время. В любой позиции вставка и удаление 
    элемента осуществляется быстро. Быстрый дсотуп к первому и последнему
    элементам. Вставка и удаление элементов не длеает некорректными
    указатели, ссылки и итераторы. Список поддерживает обработку 
    исключений, каждая операция либо выполняется успешно либо не выполняется.

6 - использование std:: forward_list

    Ограниченный список, в котором не поддерживаются все операции, 
    предусматривающие перемещение назад или вызывающие снижение 
    быстродействия. Экономия памяти по сравнению с list.

7 - адаптеры контейнеров

    Стек управляет своими элементами по принципу LIFO(последним вошел – первым вышел)
    Очередь управляет своими элементами по принципу FIFO(первым вошел – первым вышел)
    Очередь с приоритетами – контейнер, в котором элементы имеют разные 
    приоритеты. Приоритет зависит от критерия сортировки, который может
    задавать программист. 

8 - использование circular buffer из Boost

    Когда объём доступной памяти ограничен, и нужно предотвратить 
    произвольный рост контейнера. Или непрерывный поток данных, когда
    старые данные становятся ненужными по мере появления новых. Память 
    автоматически используется повторно путем перезаписи старых данных.

9 - circular buffer из Boost не в стандарте

    Потому что это круговой контейнер,  и возможна ситуация begin > end.

10 - типы данных для работ с многомерными массивами
    Boost:multiarray
    вектор векторов 
    std::valarray
    встроенные массивы
    контейнер контейнеров 

