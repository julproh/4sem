/*
Ассоциативные и неупорядоченные контейнеры
map, set на основе бинарного дерева поиска (красного-черного)
1 - Дерево 
    Листья и узлы
2 - Бинарное дерево  - не больше двух потомков
3 - -//- поиска
Р - родиель, l- левый потомок, r - правый потомок
l <= p <= r
__________________
RBT - красно черное дерево
0 - Оно является бинрным деревом поиска
1 - Все вершины либо красные, либо черные
2 - Все листья - черные, корень  - черный
3 - Все потомки красного  узла - черные
4 - Во всех простых путях от корня до листьев одинаковое число черных вершин
____________________________
шоб быстро балансировать

Lmax < 2 Lmin
B - количество черных вершин
2Lmin >= B
Lmax <= 2B
____________________
Find ~ lnn
Insert ~lnn+rotation
Delete ~ln n +rotation
_____________________
map
keys -> values
______________
unordered_map и unordered_set

1 - Хэш-функция
    1 - быстрый h = f(x) примерно за длину х
    2 - Детерменизм - одно и то же на вход  = одно и то же на выход
    3 - Равномерность 
    * - Лавинный эффект
key -> hash(key)
коллизия - разные ключи в одну ячейку
2 - Хэш со вставками (как вариант хэш от хэша) 
3 - Хэш цепочка (добавляем форвард лист 
Insert, Find, Delete - o(1) - в хорошем случае
с плохом o(n)
*/

#include <iostream>

    using namespace std;;

    size_t hash(const char *s) 
    {
        auto h = 0U;
        for (auto p = s; *p != '\0'; ++p){
            h = h*31+static_cast<unsigned int> (*p);
        }
        return h%128;
    }
